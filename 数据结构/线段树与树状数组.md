# 线段树与树状数组
## 线段树
线段树用于维护区间信息。不错，还是区间信息。目前为止我们已经学习不少维护区间信息的数据结构了：前缀和、单调队列、ST表等，接下来还会有线段树与树状数组。不难看出，我们研究的区间问题越来越普遍，灵活度越来越高。从开始的仅适合任意次数增加、唯一查询到现在适合任意区间运算、任意次查询，数据结构也越发复杂，现在的树性结构可谓终极形态，因为“树总是最优的”。
**定义**：线段树既不是AVL树，也不是完全二叉树，更不是满二叉树，它只是高度上平衡的二叉树。树上每一个节点代表了一段区间，父亲节点的区间分割成两个更细的孩子节点区间。根节点区间涵盖整个目标数组，叶子节点区间只是一个数组元素（左右边界相等）。
### 线段树的建立
线段树是抽象的逻辑结构，建立时必须考虑具象为实体存储。我们用最牛八的数组（起名为tree）存它，数组下标为节点编号，对应的值为区间之和。父亲节点下标为`i`，则两个儿子节点下标为`2*i`和`2*i+1`。
假设父节点p存储区间[a,b]之和，那么两个子节点分别存储[a,mid]之和、[mid+1,b]之和（其中mid是a，b的平均数向下取整）。
代码实现时，将建立函数命名为`biuld()`。采用递归法不断给节点赋上和的初值，类似于后序遍历——先遍历左孩子，再遍历右孩子，最后是自己。
### 区间修改
要求修改的区间一般不会恰好对应唯一一个节点，大多数情况下需要修改某一父节点下好多孩子。可以直观地感受到，递归深度可能不低，有没有改进的方法？有，线段树的特色——懒标记。引用知乎中的一句话：
*“对于区间修改，朴素的想法是用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个标记，将来要用到它的子区间的时候，再向下传递。”*
懒标记需要额外的$O(n)$大小数组mark，这个数组中的值可以由父到子方向传递。
区间修改三种情况：
1. 当前区间与目标区间没有交集
   - 这时直接结束递归。
2. 当前区间被包括在目标区间里
   - 同时修改tree数组和mark数组，都执行+=操作。
3. 当前区间与目标区间相交，但不包含于其中
   - 首先需要对目标区间进行拆分，直到对于每个孩子区间都符合上面两种情况为止。拆分的过程定义为函数`push_down()`。
   - 拆分完后，递归地处理子节点，类似于后序遍历。

至于单点修改，这是区间修改中左右边界相等的特例，不再赘述。
### 区间查询
区间查询时，懒标记的节点起到作用。这时它必须把区间修改时的影响下放到每一个被查询到的元素上。按照这种思路，区间查询也有三种情况，与区间修改类似：
1. 当前区间与目标区间没有交集
   - 这时直接结束递归，返回值0。
2. 当前区间被包括在目标区间里
   - 返回这个区间对应节点在tree数组中的值。
3. 当前区间与目标区间相交，但不包含于其中
   - 执行`push_down()`函数，递归左右子节点，直到符合上面两种情况，获得返回值。



### 板子
#### 仅支持单点修改的线段树
仅支持单点修改的线段是比较简单的线段树，不需懒标记就能实现。在ACwing课程中，我学习到一套比较简洁明了的写法，包括对树节点的定义和四个函数：pushup, build, update, query。
首先是节点定义，线段树的一个节点对应数组a的一段区间，因此一个节点就是一个结构体（成员变量有l，r，sum，意义分别是左端点，右端点以及区间和）
```c++
const int N=100010;
int a[N]; //原始数组
struct Node {
    int l,r,sum;
} tree[4*N];

```
```c++
//根据孩子节点sum更新父节点的sum
void pushup(int u) {
    tree[u].sum=tree[u<<1].sum+tree[u<<1|1].sum;
}
```
其次注意，build函数在输入所有值之后的调用。即先处理输入，等到都存放在一个数组a中之后，再执行build函数。
```c++
//递归函数，调用一遍，分别传入原始数组左端点，右端点和根节点下标
void build(int l=1,int r=n,int u=1) {
    if(l==r) 
        tree[u]={l,r,a[l]}; //处理叶子节点
    else {
        tree[u]={l,r} //先赋上做右端点，sum此时为0
        int mid=l+r>>1;
        //遍历左右孩子
        build(l,mid,u<<1);
        build(mid+1,r,u<<1|1);
        //父节点的sum由已经得出的左右孩子节点的sum求出
        pushup(u);
    }
}
```
```c++
//递归函数，对于节点u，把数组a中下标为x的元素值加上v
void update(int u=1,int x,int v) {
    if(tree[u].l==tree[u],r)
        tree[u].sum+=v;
    else {
        int mid=tree[u].l+tree[u].r>>1;
        if(x<=mid)
            update(u<<1,x,v);
        else
            update(u<<1|1,x,v);
        pushup(u);
    }
}
```
```c++
//递归函数，对于每次查询给出l和r，查询在数组a中的区间和
int query(int l,int r,int u=1) {
    if(tree[u].l>=l&&tree[u].r<=r)
        return tree[u].sum;
    int mid=tree[u].l+tree[u].r>>1;
    int sum=0;
    if(l<=mid)
        sum=query(l,r,u<<1);
    if(r>mid)
        sum+=query(l,r,u<<1|1);
    return sum;
}
```

#### 支持区间修改的线段树（增加lazy tag）
数据类型`ll`可以替换成其他任意。
```c++
void build(int l, int r, int p) {
    if(l==r) {
        tree[p]=a[l];
        return;
    }
    int mid=(l+r)/2;
    build(l,mid,2*p);
    build(mid+1,r,2*p+1);
    tree[p]=tree[2*p]+tree[2*p+1];
}
```
```c++
//修改和查询时都会用
void push_down(int p, int len) {
    tree[2*p]+=mark[p]*(len-len/2);
    tree[2*p+1]+=mark[p]*(len/2);
    mark[2*p]+=mark[p];
    mark[2*p+1]+=mark[p];
    mark[p]=0;
}
```
```c++
//修改，这里以区间加操作为例。类似的其他操作同理
void update(int l, int r, int d, int tl=1, int tr=n, int p=1) {
    if(tr<l||tl>r) {
        return;
    }
    if(tl>=l&&tr<=r) {
        tree[p]+=d*(tr-tl+1);
        if(tr>tl)
            mark[p]+=d;
    }
    else {
        push_down(p, tr-tl+1);
        int mid=(tl+tr)/2;
        update(l,r,d,tl,mid,2*p);
        update(l,r,d,mid+1,tr,2*p+1);
        tree[p]=tree[2*p]+tree[2*p+1];
    }
}
```
```c++
//查询区间和
ll query(int l, int r, int tl=1, int tr=n, int p=1) {
    if(tr<l||tl>r) {
        return 0;
    }
    if(tl>=l&&tr<=r) {
        return tree[p];
    }
    else {
        push_down(p, tr-tl+1);
        int mid=(tl+tr)/2;
        ll q1=query(l,r,tl,mid,2*p);
        ll q2=query(l,r,mid+1,tr,2*p+1);
        return q1+q2;
    }
}
```
### 综合运算问题
- 线段树只有一种区间运算——easy！
- 再加一种运算——hard！

加法和乘法的混合运算，需要维护好懒加载lazy_tag，注意乘法会改变加法的tag哦！



## 树状数组
树状数组是线段树的简化版，对于不太复杂的问题使用树状数组能获得更高的效率和更简洁的代码。换言之，树状数组之于线段树好比int加法之于高精度加法。
树状数组中每一项`c[i]`的值都来自于对应的线段树中的值（也是区间内`a[i]`之和），但是树状数组中存的更少、更精炼。对于树状数组的每一项，记下标为i，i的二进制形式末尾有几个0，那么这一项就存储从i往前数几位的和。吧 
### 初始化和更新
以上过程可以视作初始化，但是实际我们不按这种思路初始化，而是把初始化看作更新的过程。下面介绍`update()`函数。
update函数的参数是要更新的原始数组元素`a[i]`，目标是更新包含`a[i]`的每一个`c[i]`。
```c++
//在i位置加上k
void update(int i, int k) {    
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
 }
```
初始化时，输入一个更新一次。正式调用时，单次更新。
### 求区间和
使用函数`getsum(i)`求前i项元素a[i]的和，也可以理解为前缀和。同理，如果求任意区间[l,r]和，计算`getsum(r)-getsum(l-1)`即可。
```c++
//求前i项A[i]的和
int getsum(int i) {        
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}
```
### lowbit
lowbit在前面已经用到，它的作用是返回最低位的1及后的数。比如输入1100，返回100；输入1001，返回1。自己也可以想到一种实现方法：用一位的1不断左移，直到&运算等于自己就行。但还有更精妙的方法，见下面代码：
```c++
int lowbit(int x) {
    return x&(-x);
}
```
直接自己按位与自己的相反数。这涉及到补码的原理，很简单，不赘述。
### 应用
树状数组可以完成以下目标：
1. 单点修改，单点查询（退化为基本数组）
2. 区间修改，单点查询（维护的不再是原数组，而是差分数组）
3. 单点修改，区间查询（树状数组的本质）
4. 区间修改，区间查询（差分，和2一样）

至于树状数组的局限，进一步与线段树对比才能得知。

**离散化**这一思想也和树状数组有一定联系，比如经典的求逆序对。此题多解，其中一种做法是较为好理解“归并排序顺道儿做好”，另一种就是用树状数组做。
我们维护一个有序数组，一边输入，一边累加逆序对的数量。对于每次输入的a[i]，前面比它小的所有元素的个数就是它对应的逆序对个数，可以累计到ans中。一种很朴素的想法是创建一个bool类型的、范围涵盖输入数值域的数组。对于每个输入的数，其本身的值就是数组下标，给这个元素为1，否则为0。但是输入数据值域太大且分散，空间利用率不高。这就必须用到离散化处理。
离散化把分散的数据处理为集中的数据，同时不改变它们的大小关系。我们可以先对原始数组排序，再给他们分配自己的下标值，这样处理后的数据就是紧挨着的。给个例子：
```c++
struct node {
    int value,index;
} a[1001]; //按顺序输入题目给定的value
int n;
int rank[1001];
bool cmp() {
    //自定义
}
int main() {

    //输入a[i].value，此处
    //排完序之后，i和index就不一样了
    sort(a+1,a+n+1,cmp);
    //rank数组里就是聚集的相对值
    for(int i=1;i<=n;i++) {
        rank[a[i].index]=i;
    }
    //后续对rank进行操作，数组a没用了

    return 0;
}

