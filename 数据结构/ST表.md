# ST表
以下定义围绕求动态区间最值的问题解释ST表。
## 什么是ST表
ST表逻辑上是Sparse Table（稀疏表），以倍增形式存储信息的。物理上是二维数组`f[i][j]`，表示第i个元素到第$i+2^j-1$个元素的最值。（可以把$2^j$看作范围宽度）
## 实现
ST表适用于大量查询问题，这些查询一般是给出一个区间询问区间内最大或最小值。ST表可以在$O(nlogn)$内完成预处理，在$O(1)$内完成查询。
注意ST表与单调队列解决区间最值问题的不同点：ST表每次查询的区间左右边界是不固定的，而单调队列仿佛更适合于区间宽度固定、仅仅左右滑动的窗口。
**预处理**
二维数组`f[i][j]`的预处理是区间DP的思想。设待处理数组为`a[]`，考虑实际意义：
1. `f[i][0]=a[i],(宽度为1，元素本身)`
2. `f[i][j]=max(f[i][j-1],f[i+1<<(j-1)][j-1]),(宽度对半分)`

代码实现时，第一个表达式用一层for循环就可以搞定。第二个表达式使用两层循环，注意j的上下限是1到$logn$。

**查询**
上面提到，查询复杂度为 $O(1)$，看似简单，其实思路很巧妙——我们可以用两个已知区间锁定查询区间。对于每个查询[l,r]，我们把它分成两个已知区间：$f[l][l+2^k-1]$和$f[r-2^k+1][r]$，$k=⌊log(r-l+1)⌋ $
注意k那里有向下取整，如果正好得整数，则代回两个区间发现它们均为[l,r]，可以完全覆盖查询区间。
刚才那种说法不太好理解，直接看下面的代码就能看懂：取l到r之间最大2
的幂次方的长度，对应指数为k。再取两端长度等于$2^k$的区间，完全覆盖原区间。这两段区间的起点分别是$l$和$r-2^k+1$。

**板子**
```c++
#include <bits/stdc++.h>
using namespace std;

int n,m;//数组大小n，查询次数m
int a[100001];//原始数组
int f[100001][20];//动规数组
int l,r;//查询区间
int Log2[100001];//存储log的值

void init() {
    for(int i=0;i<n;i++) {
        f[i][0]=a[i];
    }  
    for(int j=1;j<20;j++) {
        for(int i=0;i+(1<<j)-1<n;i++) {
            f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
        }
    }

    for(int i=2;i<=n;i++) {
        Log2[i]=Log2[i/2]+1;
    }
}

int query(int l, int r) {
    int k=Log2[r-l+1];
    return max(f[l][k],f[r-(1<<k)+1][k]);
}

int main() {
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) {
        scanf("%d",&a[i]);
    }
    init();
    for(int i=0;i<m;i++) {
        scanf("%d%d",&l,&r);
        //注意我的数组从0开始计数
        int ans=query(l-1,r-1);
        printf("%d\n",ans);
    }

	
    system("pause");
	return 0;
}
```