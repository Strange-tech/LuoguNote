# 动态规划
## 《背包九讲》笔记
### 01背包
**问题**：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。每种物品仅有一件，可以选择放或不放。
**基本公式**：`f[i][v]=max(f[i-1][v], f[i-1][v-c[i]]+w[i])` 
`f[i][v]`表示前i件物品放入当前容量为v的背包可以获得的最大价值。
**优化**
1. 优化空间复杂度
   二维变一维。将“前i个物品”这一维度去掉，把一行一行填入二维数组的动作变为一次一次刷新一维数组的动作。实际上，二维数组我们要的也就是最后一行的最后一个，不如直接降维成一维的！
    ```c++
    for(int i=1;i<=N;i++) {
        //注意逆序更新!!
        for(int v=V;v>=c[i];v--) {
            f[v]=max(f[v],f[v-c[i]]+w[v]);
        }
    }
    ```
2. 初始化的细节
   - 如果要求“恰好装满背包的最优解”，在初始化时只把f[0]赋值为0，其他赋值为-INF（非法）。
   如果
   - 如果没有要求必须把背包装满，在初始化时f[0...N]都赋值为0。
*f初始化的意义是什么物品也没有放，各个容量下符合题意的最大价值。*
### 完全背包
**问题**：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
**基本公式**：`f[i][v]=max(f[i-1][v-k*c[i]]+k*w[i]), 0<=k*c[i]<=v`
`f[i][v]`表示前i件物品放入当前容量为v的背包可以获得的最大价值。
**优化**
上述基本公式时间复杂度太高，用01背包推演优化如下：对于当前的第i件物品，分为两种情况：不选和选若干件。因此公式优化为`f[i][v]=max(f[i-1][v], f[i][v-c[i]]+w[i])`。与01背包对比，发现只有i-1变成了i这一处细微差别。因为完全背包“最终应该选几件”取决于该件物品“已经选了几件”，如果多选一件价值更大，那就必须多选一件。
接着类比01背包，上述二维数组同样可以降维。
```c++
for(int i=1;i<=N;i++) {
    //注意顺序更新!!
    for(int v=c[i];v<=V;v++) {
        f[v]=max(f[v],f[v-c[i]]+w[v]);
    }
}
```
降维之后，对比01背包，只是第二层for循环v的遍历顺序变了。
### 多重背包
**问题**：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
**基本公式**：`f[i][v]=max(f[i-1][v-k*c[i]]+k*w[i]), 0<=k<=min(n[i],v/c[i])`
`f[i][v]`表示前i件物品放入当前容量为v的背包可以获得的最大价值。
**优化**
转化为01背包问题的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，时间复杂度仍然是O(V×∑n[i])，但是空间复杂度可降低为一维。
多重背包想进一步优化有点难度，我暂时还没搞懂-_-||

***2022-2-27 有点懂了***
由于接下来的理解参考另一位大牛的教程，对符号做重新定义。

有**n**种物品要放到一个袋子里，袋子的总容量为**m**，第i种物品的体积为**vi**，把它放进袋子里会获得**wi**的收益，可以用**li**次。问如何选择物品，使得在物品的总体积不超过m的情况下，获得最大的收益？请求出最大收益。

- 多重背包的基本解法很简单：多一重循环转换成01背包即可。
   *适用范围：`1≤n,m,vi,wi,li≤100`*
   值得注意的是，有两种写法：即先遍历j还是先遍历k。如果先遍历j，本质上并没有转换成我们熟悉的01背包问题，而是独立地分析多重背包问题本身。见如下代码：
   ```c++
   #include<bits/stdc++.h> 
   using namespace std;
   const int MAX=101;
   int n,m;
   int v[MAX],w[MAX],l[MAX]; 
   int dp[MAX]; //这里采用较优的一维dp
   int main() {
      scanf("%d%d",&n,&m);
      for(int i=1;i<=n;i++) {
         scanf("%d%d%d",&v[i],&w[i],&l[i]);
      }
      for(int i=1;i<=n;i++)
         for(int j=m;j>=v[i];j--) //这一层需要逆序
            for(int k=1;k<=l[i]&&k*v[i]<=j;k++)
               dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]); //递推公式是多重背包特有的，显然跟之前01背包递推公式不同
      printf("%d",dp[m]);
      return 0;
   }
   ```
   如果先遍历k，那么就是真正转换成了01背包问题。因为我们首先遍历了n种物品的k个不同个体（共n*k个物品），然后再考虑背包容量。见如下代码；
   ```c++
   #include<bits/stdc++.h> 
   using namespace std;
   const int MAX=101;
   int n,m;
   int v[MAX],w[MAX],l[MAX]; 
   int dp[MAX]; 
   int main() {
      scanf("%d%d",&n,&m);
      for(int i=1;i<=n;i++) {
         scanf("%d%d%d",&v[i],&w[i],&l[i]);
      }
      for(int i=1;i<=n;i++)
         for(int k=1;k<=l[i];k++) //前面两重循环相当于n*k个
            for(int j=m;j>=v[i];j--) //这一层才逆序
               dp[j]=max(dp[j],dp[j-v[i]]+w[i]); //与01背包的递推公式如出一辙
      printf("%d",dp[m]);
      return 0;
   } 
   ```
   这两种方法后者更具普适性和推广性，接下来将会看到对后者的改良。
- 多重背包的二进制优化（倍增）：回看基本解法，对于第`i`种共`l[i]`件物品，我们把每件物品作为单元视作01背包。这样遍历太慢了，需要$O(l)$的时间复杂度。二进制优化采用倍增思想，前`l`件物品可以根据$2^0, 2^1,..., 2^{i}, l-2^{i+1}+1$数列中的某些项之和得到。上述数列定义了物品的组合，选这些组合又可以看成01背包问题。不同的是，这些组合的个数是$O(logl)$，相比于线性的复杂度优化了上百倍。
  代码如下：
  ```c++
  #include<bits/stdc++.h> 
   using namespace std;
   const int MAX=2001;
   int n,m;
   int v[MAX],w[MAX],l[MAX];
   int dp[MAX];
   int main() {    
      scanf("%d%d",&n,&m);
      for(int i=1;i<=n;i++) {
         scanf("%d%d%d",&v[i],&w[i],&l[i]);
      }     
      for(int i=1;i<=n;i++) {
         int res=l[i];
         //k不再逐一递增，而是倍增
         for(int k=1;k<=res;res-=k,k*=2) {
            for(int j=m;j>=k*v[i];j--) {
               //把k*v[i]，k*w[i]看成整体——物品组，每组k个
               dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);
            }
         }
         //剩下的res个物品作为最后一组
         for(int j=m;j>=res*v[i];j--) {
            //把res*v[i]，res*w[i]看成整体——物品组，每组res个
            dp[j]=max(dp[j],dp[j-res*v[i]]+res*w[i]);
         }
      }
      printf("%d",dp[m]);   
      return 0;
   } 
   ```

- 另一种优化方法是单调队列。
  真鸡儿巴难，不想写了！

### 二维费用背包
**问题**：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。每种物品仅有一件，可以选择放或不放。
**基本公式**：`f[i][v][u]=max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]]+w[i])` 
`f[i][v][u]`表示前i件物品放入当前容量分别为V，U的背包可以获得的最大价值。
**变式**
从公式可以看出，二维费用背包其实就是比01背包多了一维而已。如果题目修改成完全背包或多重背包，同理不再赘述。
优化降维这些也很容易类比得到，不再多说。
有时候，问题不会这么明显地告诉你二维费用，具有如下变体：
1. 物品总个数的限制
   注意是*物品总个数*！不是单个物品的个数。单个物品个数有限制那就是多重背包了，而这里对总个数进行的限制就可以看作多加了一个维度的费用，直接套二位费用背包的板子即可。
2. 复数域上的背包问题
   复数`a+b*i`具有a和b两个维度的限制，这个很容易联想到二维费用。
### 分组背包
**问题**：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
**基本公式**：`f[k][v]=max(f[k-1][v], f[k-1][v-c[i]]+w[i]), 物品i属于组k` 
`f[k][v]`表示前k组物品放入当前容量为v的背包可以获得的最大价值。
**拓展**
分组背包的基本公式仍然由01背包类比得到（把f的第一维从i换成了k），实际代码书写也采用类似的方法，直接给出降维后的伪代码：
```c++
for(所有的组k) {
    //注意逆序更新!!
    for(int v=V;v>=0;v--) {
        for(所有的i属于组k) {
            if(c[i]<=v)
                f[v]=max(f[v],f[v-c[i]]+w[v]);
        }
    }
}
```
c++代码也给出来罢，挺快的，也就排名全网第5。
```c++
#include<bits/stdc++.h> 
using namespace std;
const int MAX=1001;
int n,m;
int a[MAX],v[MAX],w[MAX];
int dp[MAX];
vector<int> group[MAX];

int main() {
	int max_group=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		cin>>a[i]>>v[i]>>w[i];
		group[a[i]].push_back(i);
		max_group=max(max_group,a[i]);
	}
   //遍历所有组，这里把组类比成01背包中的每个物品
	for(int k=1;k<=max_group;k++) {
      //逆序遍历容量，更新
		for(int j=m;j>=0;j--) {
         //取每组中dp最大值，即保证每组中只选一个
			for(int i=0;i<group[k].size();i++) {
				int index=group[k][i];
				if(j>=v[index])
					dp[j]=max(dp[j],dp[j-v[index]]+w[index]);
			}
		}
	}
	cout<<dp[m];
	return 0;
} 
```
分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题，由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。
### 混合背包
问题如果将P01、P03、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？
伪代码如下：
```c++
for i ← 1 to N
   do if 第i件物品属于01背包
      then ZeroOnePack(c[i], w[i])
   else if 第i件物品属于完全背包
      then CompletePack(c[i], w[i])
   else if 第i件物品属于多重背包
      then MultiplePack(c[i], w[i], n[i])
```
应当注意，从第二重循环开始为针对一个物品的筛选过程。伪代码将三种背包问题的求解封装为函数，实际使用中直接把刚才三个背包问题的代码套进去即可。
### 有依赖的背包问题
我已经看不懂了
### 泛化物品
还是看不懂
### 背包问题问法
好家伙，这能举一反三啊

## Namomo Spring Camp笔记
动态规划来源于记忆化搜索
两个要求：最优子结构和无后效性。
- 最优子结构表示全局解可以由局部已经计算好的解得到，即计算全局解时无需拆分局部子结构，把子结构看成一个单位即可求解全局解。
- 无后效性表示后面解可以直接利用前面解的值得到，而无需关注前面解的值是怎么来的。

两个元素：状态和转移。
- 状态：定义`dp[i][j]`表示`i`,`j`情况下的某种状态
- 转移：后面的状态是怎么由前面的状态得到，一般是递推方式。

典例
1. 走楼梯
   每次可以上一层或两层 `dp[i]=dp[i-1]+dp[i-2]`
2. 最短路
   给定有向无环图DAG，路径上有权值，求起点到终点的最短路径。对于每个节点都可以找到连接到它的前置节点 `dp[k]=min(dp[i]+path(i,k))`
3. 最长上升子序列
   子序列由可以不连续的某些子元素构成。对于每个子元素，从前往后遍历它之前且小于它的元素 `dp[k]=max(dp[i]+1)`
4. 最长公共子序列
   给定两个字符串，求他们最长公共子序列（可以不连续）。采用双指针i、j，当`s1[i]==s[j]`时，`dp[i][j]=dp[i-1][j-1]+1`；当`s1[i]!=s[j]`时，`dp[i][j]=max(dp[i-1][j],dp[i][j-1])`
5. 扩展走楼梯
   小明每次可以上一阶或两阶，但是他腿不能长时间迈大步，否则容易~扯着蛋~。比如他不能连续**两次**上两阶。
   - 一维思路：定义`f[i]`为上一阶或上两阶到第`i`阶的走法，`g[i]`为上一阶到第`i`阶的走法。则`f[n]=f[n-1]+g[n-2]`（与基本走楼梯的递推式做对比，了解限制不能连续上两阶的方法），其中`g[n]=f[n-1]`。整理得：`f[n]=f[n-1]+f[n-3]`。
   - 二维思路：定义`dp[i][j]`为到第`i`阶且已经连续走了`j`次两阶的走法。很显然`j`的取值范围是[0,1]，递推公式为`dp[i][0]=sum(dp[i-1][j]), dp[i][1]=dp[i-2][0]`。
  
    小明每次可以上一阶或两阶，但是他腿不能长时间迈大步，否则容易~扯着蛋~。比如他不能连续**三次**上两阶。
    - 一维思路：与上述同理，定义`f[i], g[i], h[i]`，`f[n]=f[n-1]+g[n-2], g[n]=f[n-1]+h[n-2], h[n]=f[n-1]`。得到关于`f[n]`的递推公式`f[n]=f[n-1]+f[n-3]+f[n-5]`。
    - 二维思路：定义`dp[i][j]`为到第`i`阶且已经连续走了`j`次两阶的走法。很显然`j`的取值范围是[0,2]，递推公式同理不再赘述。
    
    小明每次可以上一阶或两阶，但是他腿不能长时间迈大步，否则容易~扯着蛋~。比如他不能连续**n次**上两阶。
    - 继续扩展到n次，发现对于一般情况，高维dp更实用。我们只需要利用二维dp数组，把`j`的取值范围更改为[0,n-1]即可。当然，用一维dp也不是不可以，这道题再扩展也就那样了···

## 区间DP
`dp[i][j]`一般定义为起点i到终点j这段区间内的最优解，或者从起点i出发往后j个长度这段区间内的最优解。
先求短的，再求长的。相当于人为递归之后，向上回归的过程。用记忆化搜索更加直接，但是效率不如前者。
区间DP包括两大类：一类是两头夹，另一类是前后遍。
### 经典问题
#### 最长回文子串（子序列）
子串定义原串中从前往后连续的一段，子序列定义为原串中从前往后可以不连续的一段。
回文串定义为翻转后与原串相同的字符串。
**问题**：给定一个字符串，求其中的最长回文子串（子序列）。
**分析**：唉先不写了，公式太麻烦，先贴代码：
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int n;
int a[1001];
int dp[1001][1001];
int ans; //2
// 区间DP，求最长回文子序列--1/子串--2
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    
    for(int i=1;i<=n;i++) {
        dp[i][i]=1;
    }
    //枚举区间长度k
    for(int k=1;k<n;k++) {
       //枚举起点i
        for(int i=1;i+k<=n;i++) {
           //终点j
            int j=i+k;
            if(a[i]==a[j]) {
                dp[i][j]=dp[i+1][j-1]+2;
                ans=max(ans,dp[i][j]); //2
            }
            // dp[i][j]=max(dp[i+1][j],dp[i][j-1]); //1
        }
    }
    // printf("%d",dp[1][n]); //1
    printf("%d",ans); //2
	return 0;
}
```
**总结**：最简单的区间DP之一
#### 括号配对
**问题**：给出一个由$(,),[,]$四个字符组成的字符串，求最少加上几个括号字符，使得该字符串成为正则括号串。正则括号串中$(,)$两两匹配，$[,]$两两匹配，如$([]),[]()$等。
**分析**：正则括号串的定义对用了两种区间DP的遍历方式，一种是两头夹，另一种是前后遍。
```c++
#include <iostream>
#include <cstring>
using namespace std;
string s;
int dp[101][101];

int main() {
	cin>>s;
	int n=s.length();
   //注意单个字符初始化为1
	for(int i=0;i<n;i++)
		dp[i][i]=1;
   //区间长度k
	for(int k=1;k<n;k++) {
      //起点i
		for(int i=0;i+k<n;i++) {
         //终点j
			int j=i+k;
         //取min，dp[i][j]初始化为大数
			dp[i][j]=100001;

         //两边匹配
			if((s[i]=='('&&s[j]==')') || (s[i]=='['&&s[j]==']')) {
				dp[i][j]=dp[i+1][j-1];
			}
         //两边不匹配
			dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j-1])+1);
			for(int p=i;p<j;p++) {
				dp[i][j]=min(dp[i][j],dp[i][p]+dp[p+1][j]);
			}	
		}
	}
	printf("%d",dp[0][n-1]);
	return 0;
}
```

## 线性DP
### 经典问题：整数划分
**问题**：已知正整数m，我们可以将其划分为若干个正整数之和。比如：划分为1个：{m}，或者划分为m个：{1,1,1,...,1}。现求划分为不超过n个正整数的方案数。（注意不考虑顺序）

**分析**：题目让求不超过n个的划分方案，可以转换成就划分成n个，但是每个数可以为0的问题。又因为题目只要求划分方案的个数，并不要求把划分方案列举出来，因此这是一道典型的动态规划问题。
状态定义： $dp[i][j]$ 表示前 $j$ 个数，和为 $i$ 的划分方案数。
初态：$dp[0][0] = 0$
终态：$dp[m][n]$
状态转移：$dp[i][j] = dp[i][j-1] + dp[i-j][j]$，将第$j$个数分为要么是0、要么不是0两种情况。如果第$j$个数为0，则当前状态由前 $j-1$ 个数且和为$i$的状态转移而来；如果第 $j$ 个数大于0，则当前状态由之前$j$个数的每个数都减去1的上一个状态转移而来。（第二个转移的条件是 $i>=j$ ）
**扩展**：如果让求一个正整数m的所有划分方案数，很显然是n=m的特殊情况。
**总结**：这题太经典了，之所以经典就是因为做法难以想到，但流传甚广。可以当作知识储备记忆。
