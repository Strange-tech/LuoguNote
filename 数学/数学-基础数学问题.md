# 基础数学问题
基础数学问题包括数论、进制转换、整除理论等基本技巧。个人认为这些技巧过一遍留有印象即可，掌握思考模式，下一次看见题有思考方向就行。
## 日期问题
判断闰年leap：四年一闰，百年不闰，四百年再闰。
闰年二月29天。
## 进制转换
### m进制转n进制
思路：m进制转10进制，10进制再转n进制。
实现：输入输出可以用`string`存储（因为有字母），10进制数用`int`或`long long`存储。每次乘一下或者每次模一下就可以。
### 负数进制转换
思路：由于模负数的结果可能是负数，所以需要转换成正的。
实现：模-=被除数，商+=1。保证了正确性和非负性。
## 位运算
### 剩余筷子
思路：把全部筷子长度全都按位异或`^`起来，结果就是没有配对的那根筷子的长度。
## 质数相关问题
### 判别质数
遍历从2到$\sqrt{n}$的数，判断能否被整除
### 埃氏筛（垃圾，基本被线性筛替代）
给定筛选质数的范围，规定质数项为0，非质数项为1。将每个质数的倍数项的值修改为1，最后剩下值为0的项就是全部质数项。
```c++
//number[]存放所有待筛选的数
//prime[]存放筛选出的质数
for(int i=2;i*i<=n;i++) {
    if(number[i]==0) {
        for(int j=i*i;j<=n;j+=i)        
            number[j]=1;
    }
}
int m=1;
for(int i=2;i<=n;i++) {
    if(number[i]==0) {
        prime[m]=i;
        m++;
    }            
}
```
<font color=red>*上述代码为什么不把两个for循环合并为一个？*</font>
我的考量有二。
其一，减少两重循环次数，去除不必要的重复操作。
其二，n值在10^5^以上时，i$\times$i的值可能会超过int的范围，造成j的值溢出（变为负数），此时仍然可以进入循环，最终造成RE。而这中写法保证i$\times$i不会溢出。

### 欧拉筛（线性筛）
规定质数项为0，非质数项为1。每一个合数只被`最小质因数`$\times$`最大因数（非自己）`的途径筛掉，这样每个合数只被筛一次，时间复杂度为O(n)。
ps：之前自学的代码就是个乐色，算法这东西自学真不行，y总我只能说yyds！
```c++
const int N=1e5+10;
int primes[N]; //存筛出来的质数
bool vis[N]; //是否 素数
int min_p[N]; //一个数的最小质因数，这个数组在分解质因数时有用
int cnt;
void get_prime() {
    for(int i=2;i<=N;i++) {
        //如果等于0，说明是素数，加入primes
        if(!vis[i]) {
            min_p[i]=i;
            primes[++cnt]=i; //从1开始
        }
        //从2（最小素数）枚举到i的最小因子，每个合数只被筛一遍
        for(int j=1;primes[j]*i<=N;j++) {
            int t=primes[j]*i;
            vis[t]=true;
            min_p[t]=primes[j];
            if(i%primes[j]==0)
                break;
        }
    }
}
```
### 质因数分解
给定一个数，求出他所有的质因数。
思路：十分巧妙，可以看作埃氏筛的逆过程——即如果我们除遍一个质数，那么接下来的数一定不会包含该质数因子。 （垃圾思路）
优化思路：利用上一题得到的min_p数组减少循环次数，同时可以得到每个质因子的重复个数。
```c++
int tot=0; //总的质因子个数，如100=2*2*5*5，tot=4
int sum[N]; //每个重复质因子的重复次数，按先后插入sum数组，注意下标没有实际意义
int k=1; //从1开始
void breakdown(int x) {
    while(x>1) {
        int p=min_p[x]; //当前x的最小质因子，注意x会更新
        //再来一次循环，除遍该质因子
        while(x%p==0) {
            x/=p;
            tot++;
            sum[k]++;
        }
        k++;
    }
}
//得到有用的tot和sum数组，供后续使用
```
质因数分解应用广泛。只要涉及对一个数进行乘法的拆分，那么每个因子必定是质因数的组合或1。比如：求把一个数拆成n个数的乘积的总方案数。
## 矩形个数
问题：考虑类似于田地一样的大矩形，大矩形被横纵划分为多个小矩形。给定长，宽代表的划分数n和m，求这样的大矩形包括多少小矩形。
思路：（这么一道看似小学奥数题的题目，也许是解决省选题的基础）从最后一行（看作底）看起，该行内部可以组成$\frac{(1+n)\times n}{2}$个小矩形。
每增加一行，该行内部还是增加这么多，但是竖着看，又可以对应多个竖着的小矩形。因此整个大矩形可以组成$\frac{(1+m)m(1+n)n}{4}$多个小矩形
扩展：如果大矩形中有些小矩形被“污染”了，计算总数的时候不应当包含这些被污染的矩形，情况变得复杂得多。一种方法是拿总数减去被污染的矩形参与组成矩形的总数，另一种方法是细化每一行的遍历方法，由$O(1)$变为$O(n^2)$。这两种思路实施时可以用单调栈优化，但是我还没看明白-_-||
## 约数相关问题
### 求一个数的全部约数
```c++
int n;
vector<int> v;
for(int i=1;i*i<=n;i++) {
    if(n%i==0) {
        v.push_back(i);
        if(n/i!=i)
            v.push_back(n/i);
    }
}
//n的全部约数存储在向量v里面
```
另一种理解：约数是质因数的组合。因此，对一个数进行质因数分解得到形如 $n=p1^{a1}*p2^{a2}*...*pk^{ak}$的表达式。对于任意约数d有 $d=p1^{b1}*p2^{b2}*...*pk^{bk}$，其中bi取值范围是0到ai。
### 求一个数的约数个数
bi取值为0到ai且互不干扰，因此组合数为$(a1+1)*(a2+1)*...*(ak+1)$，一种组合对应一个约数，亦即约数个数。
### 求一个数的约数之和
约数之和$sum=(1+p1^1+p1^2+...+p1^{a1})*(1+p2^1+p2^2+...+p2^{a2})*...*(1+pk^1+pk^2+...+pk^{ak})$
### 欧几里得算法和裴蜀定理（扩展欧式算法）
欧几里得算法对应中国古代的辗转相除法，用于求两个数的最大公约数，数学符号用$gcd(a,b)$表示。
注意：虽然GNU编译器自带__gcd()函数，但这并不是c++标准中包含的。最好自己实现一遍。
```c++
int gcd(int a,int b) {
    return b==0?a:gcd(b,a%b);
}
```
扩展欧几里得算法又名裴蜀定理，可以在求最大公约数（一般用d表示）的同时，求出满足$a*x+b*y=d$的一组解$(x0,y0)$。进而解空间为$x=x0+k*b/d, y=y0-k*a/d$。
```c++
//计算x，y的值，要传入引用
int exgcd(int a,int b,int &x,int &y) {
    if(b==0) {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
//这样求出的x，y就是一组解
```
**扩展：辗转相减法**
首先将a，b两数通过交换保证前者小，后者大。
然后通过$gcd(a,b)=gcd(a,b-a), gcd(a,0)=a$ 递归。
### 最大公约数的应用
#### 求最大公差
已知一串等差数列，公差为d（值不定）。现在给出从中任意挑出的n项，试判断原数列的最大公差是多少。
1. 先排序（如从小到大）
2. 每一项与第一项的差一定是d的整数倍
3. 要求满足要求最大的d，即求所有差的最大公约数

涉及知识：辗转相除法（欧几里得算法）
#### 求最大公比
已知一串等比数列，公比为r（写成$p/q$的互质分数形式，值不定）。现在给出从中任意挑出的n项，试判断原数列的最大公比是多少。
1. 先排序
2. 每一项与第一项的商（表示为$pi/qi$，注意先约分成互质形式）一定分别是$p/q$的相同整数倍
3. 公比$p/q$一定可以写成$(p'/q')^k$的形式（k>=1）
4. 要求最大的公比，一般人第一反应是求最大的k，但是不好求。使用辗转相减法将幂之差转换成整体之商，直接求出$p^k$整体的最大值，分母同理。

涉及知识：辗转相减法，整体代换
## 线性代数
### 矩阵乘法
这里仅列出一维矩阵×二维矩阵和二维矩阵×二维矩阵的代码。
或许我们用笔算的时候感觉很直接，但是写代码就必须掌握矩阵相乘的数学形式。下面直接给出代码，数学公式与代码等价：
```c++
//以下代码是从斐波那契求前n项和中抠出来的，答案对m取模
//c=a*b，一维×二维
void mul(int c[],int a[],int b[][N]) {
    int temp[N]={0};
    for(int i=0;i<N;i++) {
        for(int j=0;j<N;j++) {
            temp[i]=(temp[i]%m+1ll*a[j]*b[j][i]%m)%m;
        }
    }
    memcpy(c,temp,sizeof(temp));
}
//c=a*b，二维×二维
void mul(int c[][N],int a[][N],int b[][N]) {
    int temp[N][N]={0};
    for(int i=0;i<N;i++) {
        for(int j=0;j<N;j++) {
            for(int k=0;k<N;k++) {
                temp[i][j]=(temp[i][j]%m+1ll*a[i][k]*b[k][j]%m)%m;
            }
        }
    }
    memcpy(c,temp,sizeof(temp));
}
```